name: AWS multi-env deployment

permissions:
  # Allows the workflow to request an OIDC token
  id-token: write

  # Required for actions/checkout
  contents: read

  # Required for issue/PR comments
  issues: write
  pull-requests: write

on:
  # checkov:skip=CKV_GHA_7 reason="Environment selection is safe and intentional"
  workflow_dispatch:
    inputs:
      environment:
        description: "Select the environment to deploy to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - stg
          - prod
      auto_apply:
        description: "Apply Terraform changes automatically"
        required: false
        default: false
        type: boolean
  push:
    branches:
      - "main"
      - "staging"
      - "development"
      - "release/*"
      - "feature/*"
      - "bugfix/*"
  pull_request:
    branches:
      - "main"
      - "staging"
      - "development"
      - "release/*"
      - "feature/*"
      - "bugfix/*"
  issue_comment:
    types: [created]

env:
  aws_region: eu-west-3
  environment: >-
    ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment ||
        github.event_name == 'issue_comment' && (
          github.ref_name == 'main' && 'prod' ||
          github.ref_name == 'staging' && 'stg' ||
          github.ref_name == 'development' && 'dev'
        ) ||
        github.event_name == 'pull_request' && (
          github.event.pull_request.base.ref == 'main' && 'prod' ||
          github.event.pull_request.base.ref == 'staging' && 'stg' ||
          github.event.pull_request.base.ref == 'development' && 'dev'
        ) ||
        github.ref_name == 'main' && 'prod' ||
        github.ref_name == 'staging' && 'stg' ||
        github.ref_name == 'development' && 'dev' }}
  tf_version: "1.12.1"
  working_dir_tf: "terraform/live"
  working_dir_web: "web"
  tf_plugin_cache_dir: ${{ github.workspace }}/.terraform.d/plugin-cache
  terraform_approvers: '["terraform-approvers"]'
  auto_apply: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true' || github.event_name == 'push' && (github.ref == 'refs/heads/development' || github.ref == 'refs/heads/staging') }}

  # verbosity setting for Terraform logs
  TF_LOG: INFO

jobs:
  dump:
    name: Dump
    runs-on: ubuntu-latest
    steps:
      - name: Dump GitHub context
        run: echo "${{ toJSON(github) }}"

  detect_changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      terraform_changes: ${{ steps.filter.outputs.terraform }}
      web_changes: ${{ steps.filter.outputs.web }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            terraform:
              - 'terraform/**/*.tf'
            web:
              - 'web/**'

  tf_checks:
    name: TF Checks
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || needs.detect_changes.outputs.terraform_changes == 'true'
    needs: detect_changes

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS & Terraform Cache
        uses: ./.github/actions/setup-aws-tf-cache
        with:
          aws-role-arn: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}
          cache-path: ${{ env.tf_plugin_cache_dir }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.tf_version }}

      - name: Terraform Format Check
        run: |
          cd ${{ env.working_dir_tf }}
          terraform fmt -check -recursive

      - name: Terraform Init
        run: |
          cd ${{ env.working_dir_tf }}
          terraform init

      - name: Terraform Workspace
        if: env.environment != '' && env.environment != 'false' && env.environment != null
        run: |
          cd ${{ env.working_dir_tf }}
          terraform workspace select ${{ env.environment }} || terraform workspace new ${{ env.environment }}

      - name: Terraform Validate
        if: env.environment != '' && env.environment != 'false'
        run: |
          cd ${{ env.working_dir_tf }}
          terraform validate

  web_build:
    name: Web Lint, Test & Build
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || needs.detect_changes.outputs.web_changes == 'true'
    needs: [detect_changes]
    outputs:
      app_version: ${{ steps.get_version.outputs.app_version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        name: Install pnpm
        with:
          version: 9
          run_install: false

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: "pnpm"

      - name: Install dependencies
        run: |
          cd ${{ env.working_dir_web }}
          pnpm install

      - name: Run Vitest tests
        run: |
          cd ${{ env.working_dir_web }}
          pnpm test
        continue-on-error: true
        env:
          CI: true

      - name: Get App version
        id: get_version
        run: |
          cd ${{ env.working_dir_web }}
          APP_VERSION=$(node -p "require('./package.json').version")
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "App Version: $APP_VERSION"

      - name: Build project
        run: cd ${{ env.working_dir_web }} && npm run build:${{ env.environment }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: web-dist
          path: ${{ env.working_dir_web }}/dist
          retention-days: 1

  tf_plan:
    name: TF Plan
    needs: [tf_checks]
    if: env.environment != '' && env.environment != 'false' && env.environment != null
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS & Terraform Cache
        uses: ./.github/actions/setup-aws-tf-cache
        with:
          aws-role-arn: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}
          cache-path: ${{ env.tf_plugin_cache_dir }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.tf_version }}

      - name: Terraform Init
        run: |
          cd ${{ env.working_dir_tf }}
          terraform init

      - name: Terraform Workspace
        run: |
          cd ${{ env.working_dir_tf }}
          terraform workspace select ${{ env.environment }} || terraform workspace new ${{ env.environment }}

      - name: Terraform Plan
        env:
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          cd ${{ env.working_dir_tf }}
          terraform plan -out=tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ env.environment }}
          path: ${{ env.working_dir_tf }}/tfplan
          retention-days: 5

      - name: Generate Terraform Plan Output for PR
        if: github.event_name == 'pull_request'
        run: |
          cd ${{ env.working_dir_tf }}
          terraform show -no-color tfplan > plan_output.txt
          echo "PLAN_OUTPUT<<EOF" >> $GITHUB_ENV
          cat plan_output.txt >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Create Plan Summary Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const planOutput = process.env.PLAN_OUTPUT || '';
            let planSummary = "Plan: unknown";
            if (planOutput) {
              const match = planOutput.match(/(Plan:.*|No changes.*)/);
              if (match) planSummary = match[0];
            }

            const body = `### Terraform Plan Created
            **Plan Summary:** ${planSummary}

            <details>
            <summary>Click to view the full Terraform plan</summary>

            \`\`\`terraform
            ${planOutput}
            \`\`\`
            </details>

            Please review the plan and comment \`/apply\` to apply these changes.

            **Note:** Only members of the \`terraform-approvers\` team can approve and trigger the apply.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      # For workflow_dispatch with manual approval, we'll use a different approach
      - name: Generate Terraform Plan Output
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'false' || github.event_name == 'push'
        run: |
          cd ${{ env.working_dir_tf }}
          terraform show -no-color tfplan > plan_output.txt
          echo "PLAN_OUTPUT<<EOF" >> $GITHUB_ENV
          cat plan_output.txt >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Create Workflow Run Annotation for Manual Approval
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'false' || github.event_name == 'push'
        run: |
          # Create a summary of the plan using a more reliable method
          PLAN_SUMMARY=$(echo "$PLAN_OUTPUT" | grep -E 'Plan:|No changes' || echo "Plan: unknown")
          # Handle empty plan output
          if [ -z "$PLAN_OUTPUT" ]; then
            PLAN_SUMMARY="Plan: unknown (empty plan output)"
          fi

          # Create the annotation with plan details
          echo "::notice title=Manual Approval Required::Terraform plan created for environment '${{ env.environment }}'. Plan summary: $PLAN_SUMMARY. To apply, run this workflow again with auto_apply=true."

          # Write full plan to step summary
          echo "## Terraform Plan for environment: ${{ env.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "To apply this plan, run the workflow again with auto_apply=true" >> $GITHUB_STEP_SUMMARY
          echo '```terraform' >> $GITHUB_STEP_SUMMARY
          echo "$PLAN_OUTPUT" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          echo "MANUAL_APPROVAL_NEEDED=true" >> $GITHUB_ENV
        env:
          ENVIRONMENT: ${{ env.environment }}
          PLAN_OUTPUT: ${{ env.PLAN_OUTPUT }}

  tf_apply:
    name: TF Apply
    runs-on: ubuntu-latest
    needs: [tf_plan]
    if: |
      env.environment != '' && env.environment != 'false' && env.environment != null &&
      ((github.event_name == 'issue_comment' && github.event.issue.pull_request && github.event.comment.body == '/apply') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true') ||
      (github.event_name == 'push' && (github.ref == 'refs/heads/development' || github.ref == 'refs/heads/staging')))

    steps:
      - name: Check commenter team membership
        if: github.event_name == 'issue_comment'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commenter = context.payload.comment.user.login
            const teams = JSON.parse(process.env.TERRAFORM_APPROVERS)
            let isApproved = false

            try {
              // For pull request comments only
              for (const team of teams) {
                try {
                  const { data: teamMembership } = await github.rest.teams.getMembershipForUserInOrg({
                    org: context.repo.owner,
                    team_slug: team,
                    username: commenter
                  });

                  if (teamMembership.state === 'active') {
                    isApproved = true;
                    await github.rest.issues.createComment({
                      issue_number: context.issue.number,
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      body: `✅ Terraform apply approved by @${commenter} (member of ${team}) for environment: ${process.env.ENVIRONMENT}`
                    });
                    break;
                  }
                } catch (err) {
                  // User is not in this team, continue checking other teams
                  console.log(`User ${commenter} is not in team ${team}: ${err.message}`);
                }
              }

              if (!isApproved) {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `❌ @${commenter} is not authorized to approve Terraform apply. Must be a member of: ${teams.join(', ')}`
                });
                core.setFailed('Commenter is not in an approved team');
              }
            } catch (error) {
              console.error('Error checking team membership:', error);
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `❌ Error checking team membership: ${error.message}`
              });
              core.setFailed(`Error checking team membership: ${error.message}`);
            }
        env:
          TERRAFORM_APPROVERS: ${{ env.terraform_approvers }}
          ENVIRONMENT: ${{ env.environment }}

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS & Terraform Cache
        uses: ./.github/actions/setup-aws-tf-cache
        with:
          aws-role-arn: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}
          cache-path: ${{ env.tf_plugin_cache_dir }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.tf_version }}

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ env.environment }}
          path: ${{ env.working_dir_tf }}
          fail-on-error: true

      - name: Terraform Init
        run: |
          cd ${{ env.working_dir_tf }}
          terraform init

      - name: Terraform Workspace
        run: |
          cd ${{ env.working_dir_tf }}
          echo "Using environment: ${{ env.environment }}"
          terraform workspace select ${{ env.environment }} || terraform workspace new ${{ env.environment }}

      - name: Terraform Apply
        env:
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          cd ${{ env.working_dir_tf }}
          terraform apply -auto-approve tfplan

  terraform_dependency:
    name: Terraform Dependency Check
    needs: [detect_changes]
    if: needs.detect_changes.outputs.terraform_changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - run: echo "This job exists to create a dependency for s3_sync when terraform changes are detected"

  # tf_apply_auto job removed and consolidated with tf_apply

  s3_sync:
    name: Web Sync to S3
    needs: [web_build, detect_changes, terraform_dependency, tf_apply]
    if: |
      env.environment != '' && env.environment != 'false' && env.environment != null &&(github.event_name == 'workflow_dispatch' || needs.detect_changes.outputs.web_changes == 'true') &&
      (needs.tf_apply.result == 'success' || needs.tf_apply.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: web-dist
          path: web/dist

      - name: Sync to S3 Release environment
        if: env.environment == 'prod'
        run: |
          aws s3 sync web/dist s3://${{ env.environment }}-launchplate-react-primary && \
          aws s3 sync web/dist s3://${{ env.environment }}-launchplate-react-failover

      - name: Sync to S3 Pre-release environment
        if: env.environment != 'prod'
        run: |
          aws s3 sync web/dist s3://${{ env.environment }}-launchplate-react-primary

      - name: Get CloudFront Distribution ID from Terraform
        working-directory: terraform/live
        if: env.environment != '' && env.environment != 'false' && env.environment != null
        run: |
          terraform workspace select ${{ env.environment }}
          echo "CLOUDFRONT_ID=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_ENV

      - name: Invalidate CloudFront cache
        run: |
          echo "Invalidating CloudFront distribution ID: $CLOUDFRONT_ID"
          aws cloudfront create-invalidation --distribution-id $CLOUDFRONT_ID --paths '/*' || echo "⚠️ Cache invalidation failed, continuing anyway."

  slack:
    name: Slack
    needs: [s3_sync, tf_apply]
    if: always()
    runs-on: ubuntu-latest

    steps:
      # run this action to get the workflow conclusion
      - uses: technote-space/workflow-conclusion-action@v3

      # run other action with the workflow conclusion
      - uses: 8398a7/action-slack@v3
        # Prevents posting useless messages for skipped or cancelled workflows.
        if: env.WORKFLOW_CONCLUSION != 'skipped' && env.WORKFLOW_CONCLUSION != 'cancelled'

        with:
          status: custom
          fields: workflow,job,commit,repo,ref,author,took
          custom_payload: |
            {
              attachments: [{
                color: '${{ env.WORKFLOW_CONCLUSION }}' === 'success' ? 'good' : '${{ env.WORKFLOW_CONCLUSION }}' === 'failure' ? 'danger' : 'warning',
                text: `${process.env.AS_WORKFLOW}\n${process.env.AS_JOB} (${process.env.AS_COMMIT}) of ${process.env.AS_REPO}@${process.env.AS_REF} by ${process.env.AS_AUTHOR} ${{ env.WORKFLOW_CONCLUSION }} in ${process.env.AS_TOOK}`,
              }]
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
